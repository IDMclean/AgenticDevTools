import os
import ast
import glob

def get_script_docstring(filepath):
    """
    Safely extracts the module-level docstring from a Python script.
    Returns an empty string if the file cannot be parsed or has no docstring.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            tree = ast.parse(f.read(), filename=filepath)
        return ast.get_docstring(tree) or ""
    except Exception as e:
        print(f"Warning: Could not parse docstring from {filepath}: {e}")
        return ""

def get_all_protocols(protocols_dir):
    """
    Reads all .protocol.md files in the protocols directory, concatenating them
    in numerical order to create a full protocol document summary.
    """
    protocol_files = sorted(glob.glob(os.path.join(protocols_dir, "*.protocol.md")))
    if not protocol_files:
        return "No protocol documentation found."

    full_protocol = []
    for f in protocol_files:
        try:
            with open(f, 'r', encoding='utf-8') as proto_f:
                full_protocol.append(proto_f.read())
        except Exception as e:
            print(f"Warning: Could not read protocol file {f}: {e}")

    return "\n\n---\n\n".join(full_protocol)

def get_all_tooling_docs(tooling_dir):
    """
    Scans the tooling directory for all non-test Python scripts and extracts
    their module-level docstrings.
    """
    tool_files = sorted(glob.glob(os.path.join(tooling_dir, "*.py")))
    if not tool_files:
        return "No tooling scripts found."

    tooling_docs = []
    for f_path in tool_files:
        filename = os.path.basename(f_path)
        # Exclude test files and this generator itself from the documentation
        if filename.startswith("test_") or filename == "readme_generator.py":
            continue

        docstring = get_script_docstring(f_path)
        if docstring:
            # Format with a header for each tool
            tooling_docs.append(f"### `{filename}`\n\n```\n{docstring.strip()}\n```")

    return "\n\n".join(tooling_docs)


def generate_readme():
    """
    Generates the README.md file by assembling documentation from protocols,
    tooling scripts, and a static overview.
    """
    print("--> Starting comprehensive README.md generation...")

    protocol_summary = get_all_protocols("protocols")
    tooling_documentation = get_all_tooling_docs("tooling")

    readme_content = f"""
# The Symbiont Development Environment (Auto-Generated)

**This document is automatically generated by `tooling/readme_generator.py`. Do not edit it directly.**

## Overview

This repository is a cutting-edge development environment designed for a symbiotic partnership between a human developer and the AI agent, Jules. The primary objective is to create a self-aware, self-improving system where Jules can autonomously execute and learn from complex software engineering tasks.

The system is built on three pillars:
1.  **A Formal Agent Protocol:** A clear, multi-phase process that guides the agent's reasoning and actions.
2.  **Core Tooling:** A set of Python scripts that provide the agent with its core capabilities and enforce the protocol.
3.  **A Knowledge Core:** A directory of machine-readable artifacts that serves as the agent's external memory, grounding it in the reality of the codebase.

---

## Agent Protocol

{protocol_summary.strip()}

---

## Core Tooling

The agent's operation is governed by the following scripts in the `tooling/` directory.

{tooling_documentation}

---

## Knowledge Core

The agent relies on a `knowledge_core/` directory containing machine-readable artifacts that function as its external world model. This allows the agent to overcome its inherent limitations by grounding it in a rich, automatically updated model of the codebase.
"""

    readme_path = "README.md"
    with open(readme_path, 'w', encoding='utf-8') as f:
        f.write(readme_content.strip())

    print(f"--> Successfully generated comprehensive README.md at '{readme_path}'")


if __name__ == "__main__":
    generate_readme()