# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the `protocol_compiler.py` script.
# All changes to agent protocols must be made in the source files
# located in the `protocols/` directory.
#
# This file contains the compiled protocols in a human-readable Markdown format,
# with machine-readable JSON definitions embedded.
# ---


# Jules Agent Protocol: The Hierarchical Development Cycle

**Version:** 4.0.0

---
```json
{
  "protocol_id": "aorp-header",
  "description": "Defines the identity and versioning of the Advanced Orientation and Research Protocol (AORP).",
  "rules": [
    {
      "rule_id": "aorp-identity",
      "description": "The governing protocol set is identified as the Advanced Orientation and Research Protocol (AORP).",
      "enforcement": "Protocol is identified by its name in documentation and compiled artifacts."
    },
    {
      "rule_id": "aorp-versioning",
      "description": "The official protocol version is tracked in the VERSION file in the repository root, following Semantic Versioning (SemVer).",
      "enforcement": "Build or validation scripts should verify the presence and format of the VERSION file."
    }
  ]
}
```


---

## 1. The Core Problem: Ensuring Formally Verifiable Execution

To tackle complex tasks reliably, an agent's workflow must be formally structured and guaranteed to terminateâ€”it must be **decidable**. This is achieved through a hierarchical system composed of a high-level **Orchestrator** that manages the agent's overall state and a low-level **FDC Toolchain** that governs the validity of the agent's plans. This structure prevents the system from entering paradoxical, non-terminating loops.

---
```json
{
  "protocol_id": "core-directive-001",
  "description": "The mandatory first action for any new task, ensuring a formal start to the Finite Development Cycle (FDC).",
  "rules": [
    {
      "rule_id": "mandatory-fdc-start",
      "description": "Upon receiving a new task, the agent's first action MUST be to programmatically execute the FDC 'start' command to formally initiate the task and run the AORP orientation cascade.",
      "enforcement": "This is a hard-coded behavior in the agent's core operational loop and is verified by the FDC toolchain."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py"
  ]
}
```


---

## 2. The Solution: A Two-Layered FSM System
```json
{
  "protocol_id": "decidability-constraints-001",
  "description": "Ensures all development processes are formally decidable and computationally tractable.",
  "rules": [
    {
      "rule_id": "non-turing-completeness",
      "description": "The agent's planning and execution language is, by design, not Turing-complete. This is a fundamental constraint to guarantee that all processes will terminate.",
      "enforcement": "Enforced by the design of the plan runner and validated by the `lint` command in the FDC toolchain."
    },
    {
      "rule_id": "bounded-recursion",
      "description": "The agent MUST NOT generate plans that involve recursion or self-invocation. A plan cannot trigger another FDC or a sub-plan, with the sole exception of the 'Deep Research Cycle'.",
      "enforcement": "The `lint` command in `tooling/fdc_cli.py` scans plans for disallowed recursive calls."
    },
    {
      "rule_id": "fsm-adherence",
      "description": "All plans must be valid strings in the language defined by the tooling/fdc_fsm.json Finite State Machine.",
      "enforcement": "The `lint` command in `tooling/fdc_cli.py` validates the plan against the FSM definition."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py",
    "tooling/fdc_fsm.json"
  ]
}
```


---

### Layer 1: The Orchestrator (`master_control.py` & `fsm.json`)

The Orchestrator is the master Finite State Machine (FSM) that guides the agent through its entire lifecycle, from orientation to submission. It is not directly controlled by the agent's plan but rather directs the agent's state based on the successful completion of each phase.

**Key States (defined in `tooling/fsm.json`):**
*   `ORIENTING`: The initial state where the agent gathers context.
*   `PLANNING`: The state where the Orchestrator waits for the agent to produce a `plan.txt`.
*   `EXECUTING`: The state where the Orchestrator oversees the step-by-step execution of the validated plan.
*   `POST_MORTEM`: The state for finalizing the task and recording learnings.
*   `AWAITING_SUBMISSION`: The final state before the code is submitted.

**The Orchestrator's Critical Role in Planning:**
During the `PLANNING` state, the Orchestrator's most important job is to validate the agent-generated `plan.txt`. It does this by calling the FDC Toolchain's `lint` command. **A plan that fails this check will halt the entire process, preventing the agent from entering an invalid state.**
```json
{
  "protocol_id": "orientation-cascade-001",
  "description": "Defines the mandatory, four-tiered orientation cascade that must be executed at the start of any task to establish a coherent model of the agent's identity, environment, and the world state.",
  "rules": [
    {
      "rule_id": "l1-self-awareness",
      "description": "Level 1 (Self-Awareness): The agent must first establish its own identity and inherent limitations by reading the `knowledge_core/agent_meta.json` artifact.",
      "enforcement": "The `start` command of the FDC toolchain executes this step and fails if the artifact is missing or invalid."
    },
    {
      "rule_id": "l2-repository-sync",
      "description": "Level 2 (Repository Sync): The agent must understand the current state of the local repository by loading primary artifacts from the `knowledge_core/` directory.",
      "enforcement": "The `start` command of the FDC toolchain executes this step."
    },
    {
      "rule_id": "l3-environmental-probing",
      "description": "Level 3 (Environmental Probing & Targeted RAG): The agent must discover the rules and constraints of its operational environment by executing a probe script and using targeted RAG to resolve 'known unknowns'.",
      "enforcement": "The `start` command of the FDC toolchain executes this step, utilizing tools like `google_search` and `view_text_website`."
    },
    {
      "rule_id": "l4-deep-research-cycle",
      "description": "Level 4 (Deep Research Cycle): To investigate 'unknown unknowns', the agent must initiate a formal, self-contained Finite Development Cycle (FDC) of the 'Analysis Modality'.",
      "enforcement": "This is a special case of recursion, explicitly allowed and managed by the FDC toolchain."
    }
  ],
  "associated_tools": [
    "tooling/environmental_probe.py",
    "google_search",
    "view_text_website"
  ]
}
```


---

### Layer 2: The FDC Toolchain (`fdc_cli.py` & `fdc_fsm.json`)

The FDC Toolchain is a set of utilities that the agent uses to structure its work and that the Orchestrator uses for validation. The toolchain is governed by its own FSM (`tooling/fdc_fsm.json`), which defines the legal sequence of commands *within a plan*.

#### **FDC Commands for Agent Use:**

**`start` - Task Initiation**
*   **Usage:** The first command the agent MUST issue upon receiving a task.
*   **Command:** `run_in_bash_session python3 tooling/fdc_cli.py start --task-id "your-task-id"`
*   **Function:** Logs the `TASK_START` event, formally beginning the development cycle.

**`lint` - Pre-Flight Plan Validation**
*   **Usage:** A command the agent can use to self-correct its own plan before finalizing it. The Orchestrator will *always* run this command on `plan.txt` as a mandatory check.
*   **Command:** `run_in_bash_session python3 tooling/fdc_cli.py lint <plan_file.txt>`
*   **Function:** Performs a comprehensive check against the low-level FSM:
    1.  **Closure Mandate:** Ensures the plan's final action is a call to the `close` command.
    2.  **FSM Validation:** Validates the sequence of agent tools against `tooling/fdc_fsm.json`.
    3.  **Semantic Validation:** Checks for errors like using a file before creating it.

**`close` - Task Closure**
*   **Usage:** The **last command** in any valid plan.
*   **Command:** `run_in_bash_session python3 tooling/fdc_cli.py close --task-id "your-task-id"`
*   **Function:** Logs `TASK_END`, generates a post-mortem template, and signals to the Orchestrator that plan execution is complete.
---
```json
{
  "protocol_id": "fdc-protocol-001",
  "description": "Defines the Finite Development Cycle (FDC), a formally defined process for executing a single, coherent task.",
  "rules": [
    {
      "rule_id": "fdc-entry-point",
      "description": "The AORP cascade is the mandatory entry point to every FDC.",
      "enforcement": "Enforced by the `start` command in `tooling/fdc_cli.py`."
    },
    {
      "rule_id": "fdc-state-transitions",
      "description": "The FDC is a Finite State Machine (FSM) formally defined in `tooling/fdc_fsm.json`. Plans must be valid strings in the language defined by this FSM.",
      "enforcement": "Validated by the `lint` command in `tooling/fdc_cli.py`."
    },
    {
      "rule_id": "phase1-deconstruction",
      "description": "Phase 1 (Deconstruction & Contextualization): The agent must ingest the task, query historical logs, identify entities using the symbol map, and analyze impact using the dependency graph.",
      "enforcement": "Procedural step guided by the agent's core logic, using artifacts in `logs/` and `knowledge_core/`."
    },
    {
      "rule_id": "phase2-planning",
      "description": "Phase 2 (Planning & Self-Correction): The agent must generate a granular plan, lint it using the FDC toolchain, cite evidence for its steps, and perform a critical review.",
      "enforcement": "The `lint` command in `tooling/fdc_cli.py` is a mandatory pre-flight check."
    },
    {
      "rule_id": "phase3-execution",
      "description": "Phase 3 (Execution & Structured Logging): The agent must execute the validated plan and log every action according to the `LOGGING_SCHEMA.md`.",
      "enforcement": "Logging is performed by the agent's action execution wrapper."
    },
    {
      "rule_id": "phase4-post-mortem",
      "description": "Phase 4 (Pre-Submission Post-Mortem): The agent must formally close the task using the `close` command and complete the generated post-mortem report.",
      "enforcement": "The `close` command in `tooling/fdc_cli.py` initiates this phase."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py",
    "tooling/fdc_fsm.json",
    "knowledge_core/symbols.json",
    "knowledge_core/dependency_graph.json",
    "LOGGING_SCHEMA.md"
  ]
}
```


---

### STANDING ORDERS

1.  **Orchestrator is Sovereign:** The agent's lifecycle is governed by `master_control.py`. The agent's primary job is to provide a valid `plan.txt` when the Orchestrator enters the `PLANNING` state.
2.  **Toolchain is Law:** All plans must be valid according to the `fdc_cli.py lint` command. A valid plan is one that passes the Closure Mandate and is a valid string in the language defined by `fdc_fsm.json`.
3.  **Hierarchy is Structure:** The Orchestrator (`master_control.py`) validates the agent's plan using the FDC Toolchain (`fdc_cli.py`). This separation ensures a robust, verifiable, and decidable development process, preventing the system from executing paradoxical or non-terminating plans.
```json
{
  "protocol_id": "standing-orders-001",
  "description": "A set of non-negotiable, high-priority mandates that govern the agent's behavior across all tasks.",
  "rules": [
    {
      "rule_id": "aorp-mandate",
      "description": "All Finite Development Cycles (FDCs) MUST be initiated using the FDC toolchain's 'start' command. This is non-negotiable.",
      "enforcement": "Enforced by the agent's core operational loop and the `start` command in `tooling/fdc_cli.py`."
    },
    {
      "rule_id": "rag-mandate",
      "description": "For any task involving external technologies, Just-In-Time External RAG is REQUIRED to verify current best practices. Do not trust internal knowledge.",
      "enforcement": "This is a core principle of the L3 orientation phase, utilizing tools like `google_search`."
    },
    {
      "rule_id": "fdc-toolchain-mandate",
      "description": "Use the `fdc_cli.py` tool for all core FDC state transitions: task initiation ('start'), plan linting ('lint'), and task closure ('close').",
      "enforcement": "The agent's internal logic is designed to prefer these specific tool commands for FDC state transitions."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py",
    "google_search",
    "view_text_website"
  ]
}
```


---

```json
{
  "protocol_id": "best-practices-001",
  "description": "A set of best practices derived from observing successful, data-driven workflow patterns.",
  "rules": [
    {
      "rule_id": "verify-after-write",
      "description": "After every file creation or modification action (`create_file_with_block`, `overwrite_file_with_block`, `replace_with_git_merge_diff`), the agent MUST use a subsequent read-only tool (`read_file`, `list_files`, `grep`) to verify that the action was executed successfully and had the intended effect. A plan step should only be marked as complete after this verification.",
      "enforcement": "This is a core operational discipline. Future tooling, such as a trace validator, could enforce this by analyzing the execution log against this protocol."
    }
  ],
  "associated_tools": [
    "create_file_with_block",
    "overwrite_file_with_block",
    "replace_with_git_merge_diff",
    "read_file",
    "list_files",
    "grep"
  ]
}
```


---

# System Documentation

---

## `tooling/` Directory

### `tooling/dependency_graph_generator.py`

_No module-level docstring found._

### `tooling/doc_generator.py`

_No module-level docstring found._

### `tooling/environmental_probe.py`

_No module-level docstring found._

### `tooling/fdc_cli.py`

Provides the command-line interface for the Finite Development Cycle (FDC).

This script is a core component of the agent's protocol, offering tools to ensure
that all development work is structured, verifiable, and safe. It is used by both
the agent to signal progress and the `master_control.py` orchestrator to
validate the agent's plans before execution.

The CLI provides several key commands:
- `close`: Logs the formal end of a task, signaling to the orchestrator that
  execution is complete.
- `validate`: Performs a deep validation of a plan file against the FDC's Finite
  State Machine (FSM) definition. It checks for both syntactic correctness (Is
  the sequence of operations valid?) and semantic correctness (Does the plan try
  to use a file before creating it?).
- `analyze`: Reads a plan and provides a high-level analysis of its
  characteristics, such as its computational complexity and whether it is a
  read-only or read-write plan.
- `lint`: A comprehensive "linter" that runs a full suite of checks on a plan
  file, including `validate`, `analyze`, and checks for disallowed recursion.

### `tooling/knowledge_compiler.py`

_No module-level docstring found._

### `tooling/master_control.py`

_No module-level docstring found._

### `tooling/protocol_auditor.py`

_No module-level docstring found._

### `tooling/protocol_compiler.py`

_No module-level docstring found._

### `tooling/research.py`

_No module-level docstring found._

### `tooling/research_planner.py`

_No module-level docstring found._

### `tooling/self_improvement_cli.py`

_No module-level docstring found._

### `tooling/state.py`

_No module-level docstring found._

### `tooling/symbol_map_generator.py`

_No module-level docstring found._

### `tooling/test_dependency_graph_generator.py`

_No module-level docstring found._

### `tooling/test_knowledge_compiler.py`

_No module-level docstring found._

### `tooling/test_master_control.py`

_No module-level docstring found._

### `tooling/test_self_improvement_cli.py`

_No module-level docstring found._

### `tooling/test_symbol_map_generator.py`

_No module-level docstring found._

---

## `utils/` Directory

### `utils/logger.py`

_No module-level docstring found._

### `utils/test_logger.py`

_No module-level docstring found._

---
